#!/usr/bin/env zsh
# rpi-image-writer - Write Raspberry Pi OS images to USB SSD with cloud-init provisioning
# Compatible with bash and zsh. Place in ~/.local/bin/
#
# Requires: rpi-imager >= 2.0.6, openssl, util-linux, parted
# Must be run as root (sudo rpi-image-writer)
#
# Features:
#   - Cloud-init based provisioning (RPi OS Trixie / rpi-imager 2.0+)
#   - Wired ethernet with static or DHCP configuration
#   - Optional WiFi with static or DHCP configuration
#   - Config file support: values in ./rpi-image-writer.conf override defaults
#     and skip prompts for provided values
#   - Dry-run mode: --dry-run or -n to preview without writing
#
# Config file format (shell variables in $PWD/rpi-image-writer.conf):
#   OS_IMAGE="/path/to/image.img.xz"
#   TARGET_DEVICE="/dev/sda"
#   PI_USER="roberto"
#   PI_PASS="mysecretpassword"
#   PI_HOSTNAME="rpi-node1"
#   SSH_KEY_FILE="~/.ssh/id_ed25519.pub"
#   SSH_KEY_URL="https://github.com/myuser.keys"  # fetched via curl if set
#   PI_TIMEZONE="Asia/Singapore"
#   PI_LOCALE="en_US.UTF-8"
#   PI_KEYMAP="us"
#   CONFIGURE_WIRED="yes"        # yes/no
#   WIRED_USE_DHCP="no"          # yes/no — if yes, skip static IP prompts
#   WIRED_IP="192.168.1.100/24"  # CIDR notation
#   WIRED_GATEWAY="192.168.1.1"
#   WIRED_DNS="1.1.1.1,8.8.8.8"
#   CONFIGURE_WIFI="no"          # yes/no
#   WIFI_SSID="MyNetwork"
#   WIFI_PASS="wifipassword"
#   WIFI_COUNTRY="SG"
#   WIFI_USE_DHCP="yes"          # yes/no
#   WIFI_IP="192.168.1.101/24"
#   WIFI_GATEWAY="192.168.1.1"
#   WIFI_DNS="1.1.1.1,8.8.8.8"
#   ENABLE_WRITING_SYSTEM_DRIVES="yes"  # needed for USB SSDs

set -euo pipefail

# ── Globals ───────────────────────────────────────────────────────────────────
SCRIPT_NAME="$(basename "$0")"
SCRIPT_VERSION="2.0.0"
CONFIG_FILE="${PWD}/rpi-image-writer.conf"
DRY_RUN=false
VERBOSE=false

# Minimum required rpi-imager version
MIN_IMAGER_VERSION="2.0.6"

# ── Defaults (overridden by config file, then by prompts) ────────────────────
DEFAULT_USER="roberto"
DEFAULT_HOSTNAME="rpi"
DEFAULT_LOCALE="en_US.UTF-8"
DEFAULT_TIMEZONE="Asia/Singapore"
DEFAULT_KEYMAP="us"
DEFAULT_SSH_KEY_FILE="${SUDO_USER:+$(eval echo "~${SUDO_USER}")}/.ssh/id_ed25519.pub"
DEFAULT_WIFI_COUNTRY="SG"
DEFAULT_WIRED_DNS="1.1.1.1,8.8.8.8"
DEFAULT_WIFI_DNS="1.1.1.1,8.8.8.8"
DEFAULT_ENABLE_WRITING_SYSTEM_DRIVES="yes"

# ── Colors ────────────────────────────────────────────────────────────────────
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
DIM='\033[2m'
BOLD='\033[1m'
NC='\033[0m'

info()    { printf "${CYAN}▸${NC} %s\n" "$*"; }
warn()    { printf "${YELLOW}⚠${NC} %s\n" "$*"; }
err()     { printf "${RED}✖${NC} %s\n" "$*" >&2; }
ok()      { printf "${GREEN}✔${NC} %s\n" "$*"; }
header()  { printf "\n${BOLD}${CYAN}── %s ──${NC}\n\n" "$*"; }
dry_run() { printf "${YELLOW}[DRY-RUN]${NC} %s\n" "$*"; }
debug()   { $VERBOSE && printf "${DIM}[DEBUG] %s${NC}\n" "$*" || true; }

# ── Usage ─────────────────────────────────────────────────────────────────────
usage() {
    cat <<EOF
Usage: sudo $SCRIPT_NAME [OPTIONS]

Write a Raspberry Pi OS image to a USB SSD with cloud-init provisioning.
Requires rpi-imager >= $MIN_IMAGER_VERSION. Must be run as root.

Options:
  -n, --dry-run     Preview all generated configs without writing anything
  -c, --config FILE Use specified config file (default: ./rpi-image-writer.conf)
  -v, --verbose     Show debug output
  -h, --help        Show this help
  -V, --version     Show version

Config file:
  If \$PWD/rpi-image-writer.conf exists, values defined there override defaults
  and skip interactive prompts for those fields. See script header for format.

Examples:
  sudo $SCRIPT_NAME                    # Interactive with defaults
  sudo $SCRIPT_NAME --dry-run          # Preview without writing
  sudo $SCRIPT_NAME -c mynode.conf     # Use custom config file
EOF
    exit 0
}

# ── Argument Parsing ──────────────────────────────────────────────────────────
parse_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -n|--dry-run)  DRY_RUN=true; shift ;;
            -c|--config)   CONFIG_FILE="$2"; shift 2 ;;
            -v|--verbose)  VERBOSE=true; shift ;;
            -h|--help)     usage ;;
            -V|--version)  echo "$SCRIPT_NAME v$SCRIPT_VERSION"; exit 0 ;;
            *)             err "Unknown option: $1"; usage ;;
        esac
    done
}

# ── Root Check ────────────────────────────────────────────────────────────────
require_root() {
    if [[ "$(id -u)" -ne 0 ]]; then
        err "This script must be run as root."
        info "Usage: sudo $SCRIPT_NAME [OPTIONS]"
        exit 1
    fi
}

# ── Dependency Management ─────────────────────────────────────────────────────
# Map of command -> Debian package name
declare -A CMD_TO_PKG=(
    [rpi-imager]="rpi-imager"
    [openssl]="openssl"
    [lsblk]="util-linux"
    [findmnt]="util-linux"
    [partprobe]="parted"
    [curl]="curl"
)

REQUIRED_CMDS=(rpi-imager openssl lsblk findmnt partprobe curl)

apt_updated=false

ensure_apt_updated() {
    if ! $apt_updated; then
        info "Updating package lists..."
        apt-get update -qq
        apt_updated=true
    fi
}

install_package() {
    local pkg="$1"
    ensure_apt_updated
    info "Installing $pkg..."
    if apt-get install -y -qq "$pkg"; then
        ok "Installed $pkg"
    else
        err "Failed to install $pkg"
        return 1
    fi
}

check_and_install_deps() {
    local missing_cmds=()
    local missing_pkgs=()

    for cmd in "${REQUIRED_CMDS[@]}"; do
        if ! command -v "$cmd" &>/dev/null; then
            missing_cmds+=("$cmd")
            local pkg="${CMD_TO_PKG[$cmd]}"
            # Deduplicate packages (e.g. lsblk and findmnt both need util-linux)
            local already=false
            for p in "${missing_pkgs[@]+"${missing_pkgs[@]}"}"; do
                [[ "$p" == "$pkg" ]] && already=true && break
            done
            $already || missing_pkgs+=("$pkg")
        fi
    done

    if (( ${#missing_cmds[@]} == 0 )); then
        debug "All dependencies present"
        return 0
    fi

    if $DRY_RUN; then
        warn "Missing commands (would install in non-dry-run): ${missing_cmds[*]}"
        warn "Packages needed: ${missing_pkgs[*]}"
        return 0
    fi

    warn "Missing commands: ${missing_cmds[*]}"
    info "Required packages: ${missing_pkgs[*]}"

    for pkg in "${missing_pkgs[@]}"; do
        install_package "$pkg" || {
            err "Cannot proceed without $pkg"
            exit 1
        }
    done

    # Verify all commands now available
    for cmd in "${missing_cmds[@]}"; do
        if ! command -v "$cmd" &>/dev/null; then
            err "Command '$cmd' still not available after installing ${CMD_TO_PKG[$cmd]}"
            exit 1
        fi
    done

    ok "All dependencies installed"
}

# ── rpi-imager Version Check ─────────────────────────────────────────────────
version_gte() {
    # Returns 0 if $1 >= $2 using sort -V
    [[ "$(printf '%s\n%s' "$1" "$2" | sort -V | head -n1)" == "$2" ]]
}

check_imager_version() {
    local version_output
    version_output=$(rpi-imager --version 2>&1 || true)

    # Extract version number from various output formats
    local version
    version=$(echo "$version_output" | grep -oP '\d+\.\d+\.\d+' | head -1)

    if [[ -z "$version" ]]; then
        warn "Could not determine rpi-imager version from: $version_output"
        warn "Proceeding — expected >= $MIN_IMAGER_VERSION"
        return 0
    fi

    if version_gte "$version" "$MIN_IMAGER_VERSION"; then
        ok "rpi-imager version: $version (>= $MIN_IMAGER_VERSION)"
    else
        err "rpi-imager version $version is too old (need >= $MIN_IMAGER_VERSION)"
        info "Install the latest version:"
        info "  apt-get install rpi-imager"
        info "Or download from: https://github.com/raspberrypi/rpi-imager/releases"
        exit 1
    fi
}

# ── Config File Loading ───────────────────────────────────────────────────────
declare -A CONFIG_SET=()

load_config() {
    if [[ ! -f "$CONFIG_FILE" ]]; then
        debug "No config file at $CONFIG_FILE"
        return
    fi

    info "Loading config from: $CONFIG_FILE"

    while IFS= read -r line || [[ -n "$line" ]]; do
        [[ "$line" =~ ^[[:space:]]*# ]] && continue
        [[ "$line" =~ ^[[:space:]]*$ ]] && continue

        if [[ "$line" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
            local var_name="${BASH_REMATCH[1]}"
            local var_value="${BASH_REMATCH[2]}"

            # Strip surrounding quotes
            var_value="${var_value#\"}"
            var_value="${var_value%\"}"
            var_value="${var_value#\'}"
            var_value="${var_value%\'}"

            # Expand ~ to invoking user's home (not root's)
            if [[ -n "${SUDO_USER:-}" ]]; then
                local user_home
                user_home=$(eval echo "~${SUDO_USER}")
                var_value="${var_value/#\~/$user_home}"
            else
                var_value="${var_value/#\~/$HOME}"
            fi

            eval "$var_name=\"$var_value\""
            CONFIG_SET["$var_name"]=1
            debug "Config: $var_name=$var_value"
        fi
    done < "$CONFIG_FILE"
    echo
}

is_from_config() {
    [[ "${CONFIG_SET[$1]:-}" == "1" ]]
}

# ── Interactive Helpers ───────────────────────────────────────────────────────
prompt_with_default() {
    local prompt="$1"
    local default="$2"
    local var_name="$3"

    if is_from_config "$var_name"; then
        local current_val
        eval "current_val=\"\${$var_name}\""
        debug "Skipping prompt for $var_name (from config: $current_val)"
        return
    fi

    local input
    if [[ -n "$default" ]]; then
        printf "${BOLD}%s${NC} [${GREEN}%s${NC}]: " "$prompt" "$default"
    else
        printf "${BOLD}%s${NC}: " "$prompt"
    fi
    read -r input
    eval "$var_name=\"${input:-$default}\""
}

prompt_password() {
    local prompt="$1"
    local var_name="$2"

    if is_from_config "$var_name"; then
        debug "Skipping password prompt for $var_name (from config)"
        return
    fi

    local pass1 pass2
    while true; do
        printf "${BOLD}%s${NC}: " "$prompt"
        read -rs pass1
        echo
        printf "${BOLD}Confirm password${NC}: "
        read -rs pass2
        echo
        if [[ "$pass1" == "$pass2" ]]; then
            if [[ -z "$pass1" ]]; then
                warn "Password cannot be empty"
                continue
            fi
            eval "$var_name=\"\$pass1\""
            return
        else
            warn "Passwords don't match, try again"
        fi
    done
}

prompt_yes_no() {
    local prompt="$1"
    local var_name="$2"
    local default="${3:-}"

    if is_from_config "$var_name"; then
        local current_val
        eval "current_val=\"\${$var_name}\""
        debug "Skipping yes/no prompt for $var_name (from config: $current_val)"
        [[ "${current_val,,}" == "yes" || "${current_val,,}" == "y" || "${current_val,,}" == "true" || "${current_val,,}" == "1" ]]
        return
    fi

    local input
    if [[ "$default" == "yes" ]]; then
        printf "${BOLD}%s${NC} [${GREEN}Y/n${NC}]: " "$prompt"
    else
        printf "${BOLD}%s${NC} [${GREEN}y/N${NC}]: " "$prompt"
    fi
    read -r input
    input="${input:-$default}"

    if [[ "${input,,}" == "y" || "${input,,}" == "yes" ]]; then
        eval "$var_name=\"yes\""
        return 0
    else
        eval "$var_name=\"no\""
        return 1
    fi
}

# ── Device Helpers ────────────────────────────────────────────────────────────
list_block_devices() {
    lsblk -dpno NAME,SIZE,MODEL,TRAN 2>/dev/null | grep -v "loop\|sr0" || true
}

find_os_images() {
    local user_home="${HOME}"
    if [[ -n "${SUDO_USER:-}" ]]; then
        user_home=$(eval echo "~${SUDO_USER}")
    fi

    local search_dirs=("/tmp" "${user_home}/Downloads" "$user_home" "/usr/share/rpi-imager")
    for dir in "${search_dirs[@]}"; do
        if [[ -d "$dir" ]]; then
            find "$dir" -maxdepth 2 -type f \( \
                -name "*.img" -o -name "*.img.xz" -o \
                -name "*.img.gz" -o -name "*.img.zst" \
            \) 2>/dev/null || true
        fi
    done
}

# ── Cloud-init Generators ────────────────────────────────────────────────────
generate_user_data() {
    local user="$1"
    local pass_hash="$2"
    local hostname="$3"
    local ssh_key="$4"
    local timezone="$5"
    local locale="$6"
    local keymap="$7"

    cat <<EOF
#cloud-config

hostname: ${hostname}
manage_etc_hosts: true

users:
  - name: ${user}
    groups: sudo
    shell: /bin/bash
    sudo: ALL=(ALL) NOPASSWD:ALL
    lock_passwd: false
    passwd: ${pass_hash}
    ssh_authorized_keys:
      - ${ssh_key}

ssh_pwauth: false
ssh:
  emit_keys_to_console: false

timezone: ${timezone}
locale: ${locale}

keyboard:
  layout: ${keymap}

# Raspberry Pi specific options
rpi:
  imager:
    enable: false
EOF
}

generate_network_config() {
    local configure_wired="$1"
    local wired_dhcp="$2"
    local wired_ip="$3"
    local wired_gw="$4"
    local wired_dns="$5"
    local configure_wifi="$6"
    local wifi_dhcp="${7:-yes}"
    local wifi_ssid="${8:-}"
    local wifi_pass="${9:-}"
    local wifi_country="${10:-}"
    local wifi_ip="${11:-}"
    local wifi_gw="${12:-}"
    local wifi_dns="${13:-}"

    cat <<EOF
# Netplan v2 network configuration for cloud-init
network:
  version: 2
EOF

    if [[ "${configure_wired,,}" == "yes" ]]; then
        cat <<EOF
  ethernets:
    eth0:
EOF
        if [[ "${wired_dhcp,,}" == "yes" ]]; then
            cat <<EOF
      dhcp4: true
      optional: true
EOF
        else
            local dns_yaml=""
            IFS=',' read -ra dns_entries <<< "$wired_dns"
            for d in "${dns_entries[@]}"; do
                dns_yaml="${dns_yaml}        - ${d// /}\n"
            done

            cat <<EOF
      dhcp4: false
      addresses:
        - ${wired_ip}
      routes:
        - to: default
          via: ${wired_gw}
      nameservers:
        addresses:
$(printf "$dns_yaml")
      optional: true
EOF
        fi
    fi

    if [[ "${configure_wifi,,}" == "yes" && -n "$wifi_ssid" ]]; then
        cat <<EOF
  wifis:
    wlan0:
EOF
        if [[ "${wifi_dhcp,,}" == "yes" ]]; then
            cat <<EOF
      dhcp4: true
      optional: true
      regulatory-domain: ${wifi_country}
      access-points:
        "${wifi_ssid}":
          password: "${wifi_pass}"
EOF
        else
            local wifi_dns_yaml=""
            IFS=',' read -ra wifi_dns_entries <<< "$wifi_dns"
            for d in "${wifi_dns_entries[@]}"; do
                wifi_dns_yaml="${wifi_dns_yaml}        - ${d// /}\n"
            done

            cat <<EOF
      dhcp4: false
      optional: true
      addresses:
        - ${wifi_ip}
      routes:
        - to: default
          via: ${wifi_gw}
      nameservers:
        addresses:
$(printf "$wifi_dns_yaml")
      regulatory-domain: ${wifi_country}
      access-points:
        "${wifi_ssid}":
          password: "${wifi_pass}"
EOF
        fi
    fi
}

generate_meta_data() {
    local hostname="$1"
    cat <<EOF
instance-id: iid-${hostname}-$(date +%s)
local-hostname: ${hostname}
EOF
}

# ── Post-write: mount boot partition and write cloud-init files ───────────────
write_cloud_init_files() {
    local device="$1"
    local user_data="$2"
    local network_config="$3"
    local meta_data="$4"

    local boot_part=""
    if [[ "$device" == *"nvme"* || "$device" == *"mmcblk"* ]]; then
        boot_part="${device}p1"
    else
        boot_part="${device}1"
    fi

    info "Waiting for partitions to appear..."
    sleep 2
    partprobe "$device" 2>/dev/null || true
    sleep 1

    if [[ ! -b "$boot_part" ]]; then
        err "Boot partition not found at $boot_part"
        warn "Saving generated files to /tmp/rpi-cloud-init/ for manual placement"
        mkdir -p /tmp/rpi-cloud-init
        echo "$user_data"      > /tmp/rpi-cloud-init/user-data
        echo "$network_config" > /tmp/rpi-cloud-init/network-config
        echo "$meta_data"      > /tmp/rpi-cloud-init/meta-data
        return 1
    fi

    local mount_point
    mount_point=$(mktemp -d /tmp/rpi-boot.XXXXXX)

    info "Mounting boot partition: $boot_part → $mount_point"
    mount "$boot_part" "$mount_point"

    info "Writing cloud-init files..."
    echo "$user_data"      > "$mount_point/user-data"
    echo "$network_config" > "$mount_point/network-config"
    echo "$meta_data"      > "$mount_point/meta-data"

    ok "Cloud-init files written to boot partition"

    info "Unmounting boot partition..."
    umount "$mount_point"
    rmdir "$mount_point"

    return 0
}

# ── Main ──────────────────────────────────────────────────────────────────────
main() {
    parse_args "$@"

    header "Raspberry Pi Image Writer v${SCRIPT_VERSION}"

    if $DRY_RUN; then
        warn "DRY-RUN MODE — no writes will be performed"
        echo
    fi

    # ── Pre-flight ────────────────────────────────────────────────────────
    require_root
    check_and_install_deps

    if ! $DRY_RUN; then
        check_imager_version
    else
        if command -v rpi-imager &>/dev/null; then
            check_imager_version
        else
            warn "rpi-imager not installed (ignored in dry-run)"
        fi
    fi

    load_config

    # ── OS Image ──────────────────────────────────────────────────────────
    header "OS Image"

    if ! is_from_config "OS_IMAGE"; then
        info "Searching for OS images..."
        local images
        images=$(find_os_images)

        if [[ -n "$images" ]]; then
            info "Found images:"
            local i=1
            local image_list=()
            while IFS= read -r img; do
                printf "  ${BOLD}%d)${NC} %s\n" "$i" "$img"
                image_list+=("$img")
                ((i++))
            done <<< "$images"
            echo

            local img_choice
            prompt_with_default "Select image number or enter path" "1" img_choice

            if [[ "${img_choice:-1}" =~ ^[0-9]+$ ]] && (( img_choice >= 1 && img_choice <= ${#image_list[@]} )); then
                OS_IMAGE="${image_list[$((img_choice - 1))]}"
            else
                OS_IMAGE="$img_choice"
            fi
        else
            prompt_with_default "Path to OS image" "" OS_IMAGE
        fi
    fi

    if ! $DRY_RUN && [[ ! -f "${OS_IMAGE:-}" ]]; then
        err "Image not found: ${OS_IMAGE:-<empty>}"
        exit 1
    fi
    ok "Image: ${OS_IMAGE:-<not set>}"

    # ── Target Device ─────────────────────────────────────────────────────
    header "Target Device"

    if ! is_from_config "TARGET_DEVICE"; then
        info "Available block devices:"
        echo
        list_block_devices
        echo
        prompt_with_default "Target device (e.g. /dev/sda)" "" TARGET_DEVICE
    fi

    if ! $DRY_RUN && [[ ! -b "${TARGET_DEVICE:-}" ]]; then
        err "Device not found: ${TARGET_DEVICE:-<empty>}"
        exit 1
    fi

    # Safety: refuse to write to root device
    if ! $DRY_RUN; then
        local root_dev
        root_dev=$(findmnt -no SOURCE / 2>/dev/null | sed 's/[0-9]*$//' | sed 's/p[0-9]*$//' || echo "")
        if [[ "${TARGET_DEVICE:-}" == "$root_dev" ]]; then
            err "Refusing to write to root device!"
            exit 1
        fi
    fi

    ok "Target: ${TARGET_DEVICE:-<not set>}"

    # ── User Configuration ────────────────────────────────────────────────
    header "User Configuration"

    prompt_with_default "Username" "$DEFAULT_USER" PI_USER
    prompt_password "Password for ${PI_USER:-$DEFAULT_USER}" PI_PASS
    prompt_with_default "Hostname" "$DEFAULT_HOSTNAME" PI_HOSTNAME

    # ── SSH Key ───────────────────────────────────────────────────────────
    header "SSH Configuration"

    SSH_KEY_FILE="${SSH_KEY_FILE:-$DEFAULT_SSH_KEY_FILE}"
    local ssh_key=""

    # Priority: SSH_KEY_URL > SSH_KEY_FILE (from config) > interactive
    if is_from_config "SSH_KEY_URL" && [[ -n "${SSH_KEY_URL:-}" ]]; then
        info "Fetching SSH key from URL: $SSH_KEY_URL"
        ssh_key=$(curl -fsSL "$SSH_KEY_URL") || {
            err "Failed to fetch SSH key from: $SSH_KEY_URL"
            exit 1
        }
        if [[ -z "$ssh_key" ]]; then
            err "SSH key URL returned empty content: $SSH_KEY_URL"
            exit 1
        fi
        ok "SSH key fetched from URL (${ssh_key:0:30}...)"
    elif is_from_config "SSH_KEY_FILE"; then
        if [[ -f "$SSH_KEY_FILE" ]]; then
            ssh_key=$(cat "$SSH_KEY_FILE")
            ok "SSH key from config: $SSH_KEY_FILE"
        else
            err "SSH key file from config not found: $SSH_KEY_FILE"
            exit 1
        fi
    else
        if [[ -f "$DEFAULT_SSH_KEY_FILE" ]]; then
            info "Found SSH key: $DEFAULT_SSH_KEY_FILE"
            local use_default_key="yes"
            if prompt_yes_no "Use this key?" use_default_key "yes"; then
                ssh_key=$(cat "$DEFAULT_SSH_KEY_FILE")
            fi
        fi

        if [[ -z "$ssh_key" ]]; then
            local ssh_dir="${DEFAULT_SSH_KEY_FILE%/*}"
            local key_files
            key_files=$(find "$ssh_dir" -name "*.pub" 2>/dev/null || true)
            if [[ -n "$key_files" ]]; then
                info "Available public keys:"
                local i=1
                local key_list=()
                while IFS= read -r kf; do
                    printf "  ${BOLD}%d)${NC} %s\n" "$i" "$kf"
                    key_list+=("$kf")
                    ((i++))
                done <<< "$key_files"
                echo

                local key_choice
                prompt_with_default "Select key number or enter path" "1" key_choice

                if [[ "${key_choice:-1}" =~ ^[0-9]+$ ]] && (( key_choice >= 1 && key_choice <= ${#key_list[@]} )); then
                    ssh_key=$(cat "${key_list[$((key_choice - 1))]}")
                else
                    ssh_key=$(cat "$key_choice")
                fi
            else
                local ssh_key_path
                prompt_with_default "Path to SSH public key" "" ssh_key_path
                ssh_key=$(cat "$ssh_key_path")
            fi
        fi
    fi

    if [[ -z "$ssh_key" ]]; then
        err "No SSH key provided"
        exit 1
    fi
    ok "SSH key loaded (${ssh_key:0:30}...)"

    # ── Locale / Timezone ─────────────────────────────────────────────────
    header "Locale & Timezone"

    prompt_with_default "Timezone" "$DEFAULT_TIMEZONE" PI_TIMEZONE
    prompt_with_default "Locale" "$DEFAULT_LOCALE" PI_LOCALE
    prompt_with_default "Keyboard layout" "$DEFAULT_KEYMAP" PI_KEYMAP

    # ── Networking ────────────────────────────────────────────────────────
    header "Network Configuration"

    CONFIGURE_WIRED="${CONFIGURE_WIRED:-}"
    if prompt_yes_no "Configure wired ethernet?" CONFIGURE_WIRED "yes"; then
        WIRED_USE_DHCP="${WIRED_USE_DHCP:-}"
        if prompt_yes_no "  Use DHCP for wired?" WIRED_USE_DHCP "no"; then
            debug "Wired: DHCP"
        else
            prompt_with_default "  Static IP (CIDR, e.g. 192.168.1.100/24)" "${WIRED_IP:-}" WIRED_IP
            prompt_with_default "  Default gateway" "${WIRED_GATEWAY:-}" WIRED_GATEWAY
            prompt_with_default "  DNS servers (comma-separated)" "$DEFAULT_WIRED_DNS" WIRED_DNS
        fi
    fi

    CONFIGURE_WIFI="${CONFIGURE_WIFI:-}"
    if prompt_yes_no "Configure WiFi?" CONFIGURE_WIFI "no"; then
        prompt_with_default "  WiFi SSID" "${WIFI_SSID:-}" WIFI_SSID
        prompt_password "  WiFi password" WIFI_PASS
        prompt_with_default "  WiFi country code" "$DEFAULT_WIFI_COUNTRY" WIFI_COUNTRY

        WIFI_USE_DHCP="${WIFI_USE_DHCP:-}"
        if prompt_yes_no "  Use DHCP for WiFi?" WIFI_USE_DHCP "yes"; then
            debug "WiFi: DHCP"
        else
            prompt_with_default "  WiFi static IP (CIDR)" "${WIFI_IP:-}" WIFI_IP
            prompt_with_default "  WiFi gateway" "${WIFI_GATEWAY:-}" WIFI_GATEWAY
            prompt_with_default "  WiFi DNS servers (comma-separated)" "$DEFAULT_WIFI_DNS" WIFI_DNS
        fi
    fi

    # ── Generate Configs ──────────────────────────────────────────────────
    header "Generating Cloud-init Configuration"

    local pass_hash
    pass_hash=$(openssl passwd -6 "${PI_PASS:-password}")

    local user_data
    user_data=$(generate_user_data \
        "${PI_USER:-$DEFAULT_USER}" \
        "$pass_hash" \
        "${PI_HOSTNAME:-$DEFAULT_HOSTNAME}" \
        "$ssh_key" \
        "${PI_TIMEZONE:-$DEFAULT_TIMEZONE}" \
        "${PI_LOCALE:-$DEFAULT_LOCALE}" \
        "${PI_KEYMAP:-$DEFAULT_KEYMAP}" \
    )

    local network_config
    network_config=$(generate_network_config \
        "${CONFIGURE_WIRED:-no}" \
        "${WIRED_USE_DHCP:-yes}" \
        "${WIRED_IP:-}" \
        "${WIRED_GATEWAY:-}" \
        "${WIRED_DNS:-$DEFAULT_WIRED_DNS}" \
        "${CONFIGURE_WIFI:-no}" \
        "${WIFI_USE_DHCP:-yes}" \
        "${WIFI_SSID:-}" \
        "${WIFI_PASS:-}" \
        "${WIFI_COUNTRY:-$DEFAULT_WIFI_COUNTRY}" \
        "${WIFI_IP:-}" \
        "${WIFI_GATEWAY:-}" \
        "${WIFI_DNS:-$DEFAULT_WIFI_DNS}" \
    )

    local meta_data
    meta_data=$(generate_meta_data "${PI_HOSTNAME:-$DEFAULT_HOSTNAME}")

    ok "Cloud-init configs generated"

    # ── Summary ───────────────────────────────────────────────────────────
    header "Configuration Summary"

    printf "  ${BOLD}Image:${NC}      %s\n" "${OS_IMAGE:-<not set>}"
    printf "  ${BOLD}Device:${NC}     %s\n" "${TARGET_DEVICE:-<not set>}"
    printf "  ${BOLD}Hostname:${NC}   %s\n" "${PI_HOSTNAME:-$DEFAULT_HOSTNAME}"
    printf "  ${BOLD}User:${NC}       %s\n" "${PI_USER:-$DEFAULT_USER}"
    printf "  ${BOLD}SSH Key:${NC}    %s...\n" "${ssh_key:0:40}"
    printf "  ${BOLD}Timezone:${NC}   %s\n" "${PI_TIMEZONE:-$DEFAULT_TIMEZONE}"
    printf "  ${BOLD}Locale:${NC}     %s\n" "${PI_LOCALE:-$DEFAULT_LOCALE}"

    if [[ "${CONFIGURE_WIRED:-no}" == "yes" ]]; then
        if [[ "${WIRED_USE_DHCP:-yes}" == "yes" ]]; then
            printf "  ${BOLD}Wired:${NC}      DHCP\n"
        else
            printf "  ${BOLD}Wired:${NC}      Static %s via %s\n" "${WIRED_IP:-}" "${WIRED_GATEWAY:-}"
            printf "  ${BOLD}Wired DNS:${NC}  %s\n" "${WIRED_DNS:-}"
        fi
    else
        printf "  ${BOLD}Wired:${NC}      ${DIM}not configured${NC}\n"
    fi

    if [[ "${CONFIGURE_WIFI:-no}" == "yes" ]]; then
        if [[ "${WIFI_USE_DHCP:-yes}" == "yes" ]]; then
            printf "  ${BOLD}WiFi:${NC}       %s (DHCP)\n" "${WIFI_SSID:-}"
        else
            printf "  ${BOLD}WiFi:${NC}       %s static %s via %s\n" "${WIFI_SSID:-}" "${WIFI_IP:-}" "${WIFI_GATEWAY:-}"
        fi
    else
        printf "  ${BOLD}WiFi:${NC}       ${DIM}not configured${NC}\n"
    fi
    echo

    # ── Dry-run output ────────────────────────────────────────────────────
    if $DRY_RUN; then
        header "Generated: user-data"
        printf "${DIM}"
        echo "$user_data"
        printf "${NC}"

        header "Generated: network-config"
        printf "${DIM}"
        echo "$network_config"
        printf "${NC}"

        header "Generated: meta-data"
        printf "${DIM}"
        echo "$meta_data"
        printf "${NC}"

        mkdir -p /tmp/rpi-cloud-init
        echo "$user_data"      > /tmp/rpi-cloud-init/user-data
        echo "$network_config" > /tmp/rpi-cloud-init/network-config
        echo "$meta_data"      > /tmp/rpi-cloud-init/meta-data

        header "Dry-run: rpi-imager command"

        local imager_cmd="rpi-imager --cli"
        if [[ "${ENABLE_WRITING_SYSTEM_DRIVES:-$DEFAULT_ENABLE_WRITING_SYSTEM_DRIVES}" == "yes" ]]; then
            imager_cmd+=" --enable-writing-system-drives"
        fi
        imager_cmd+=" \"${OS_IMAGE:-<image>}\" \"${TARGET_DEVICE:-<device>}\""

        dry_run "$imager_cmd"
        echo
        dry_run "Then mount boot partition and write cloud-init files from /tmp/rpi-cloud-init/"
        echo
        ok "Generated files saved to /tmp/rpi-cloud-init/"
        return 0
    fi

    # ── Confirmation ──────────────────────────────────────────────────────
    warn "This will ERASE ALL DATA on ${TARGET_DEVICE}"
    echo
    local confirm_write="no"
    if ! prompt_yes_no "Proceed with writing?" confirm_write "no"; then
        info "Aborted."
        exit 0
    fi

    # ── Write Image ───────────────────────────────────────────────────────
    header "Writing Image"

    local imager_args=("--cli")

    if [[ "${ENABLE_WRITING_SYSTEM_DRIVES:-$DEFAULT_ENABLE_WRITING_SYSTEM_DRIVES}" == "yes" ]]; then
        imager_args+=("--enable-writing-system-drives")
        debug "Enabled writing to system drives (for USB SSDs)"
    fi

    imager_args+=("$OS_IMAGE" "$TARGET_DEVICE")

    info "Running: rpi-imager ${imager_args[*]}"
    echo

    rpi-imager "${imager_args[@]}"
    local exit_code=$?

    if [[ $exit_code -ne 0 ]]; then
        err "rpi-imager exited with code $exit_code"
        exit $exit_code
    fi

    ok "Image written successfully"

    # ── Write Cloud-init Files ────────────────────────────────────────────
    header "Writing Cloud-init Files"

    if write_cloud_init_files "$TARGET_DEVICE" "$user_data" "$network_config" "$meta_data"; then
        echo
        ok "All done! Your Raspberry Pi is ready to boot."
        echo
        info "On first boot, cloud-init will:"
        info "  • Create user '${PI_USER:-$DEFAULT_USER}' with SSH key access"
        info "  • Set hostname to '${PI_HOSTNAME:-$DEFAULT_HOSTNAME}'"
        if [[ "${CONFIGURE_WIRED:-no}" == "yes" && "${WIRED_USE_DHCP:-yes}" != "yes" ]]; then
            info "  • Configure wired ethernet with IP ${WIRED_IP}"
            info "  → SSH: ssh ${PI_USER:-$DEFAULT_USER}@${WIRED_IP%%/*}"
        else
            info "  → SSH: ssh ${PI_USER:-$DEFAULT_USER}@${PI_HOSTNAME:-$DEFAULT_HOSTNAME}.local"
        fi
    else
        warn "Cloud-init files could not be written to boot partition."
        warn "Check /tmp/rpi-cloud-init/ for the generated files."
        warn "Mount the boot partition manually and copy them."
    fi
}

main "$@"

