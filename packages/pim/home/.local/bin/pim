#!/usr/bin/env ruby
# frozen_string_literal: true

require 'thor'
require 'yaml'
require 'erb'
require 'webrick'
require 'socket'
require 'pathname'
require 'fileutils'

# Load subcommand libraries
require 'pim-iso'
require 'pim-profile'

module Pim
  # Deep merge utility for configuration hashes
  module DeepMerge
    def self.merge(base, overlay)
      return overlay.dup if base.nil?
      return base.dup if overlay.nil?

      base.merge(overlay) do |_key, old_val, new_val|
        if old_val.is_a?(Hash) && new_val.is_a?(Hash)
          merge(old_val, new_val)
        else
          new_val
        end
      end
    end
  end

  # Configuration loader for pim
  class Config
    XDG_CONFIG_HOME = ENV.fetch('XDG_CONFIG_HOME', File.expand_path('~/.config'))
    GLOBAL_CONFIG_DIR = File.join(XDG_CONFIG_HOME, 'pim')

    attr_reader :runtime_config

    def initialize(project_dir: Dir.pwd)
      @project_dir = project_dir
      @runtime_config = load_runtime_config
      @profile_config = PimProfile::Config.new(project_dir: project_dir)
    end

    def profile(name)
      @profile_config.profile(name)
    end

    def profile_names
      @profile_config.profile_names
    end

    def serve_defaults
      @runtime_config['serve'] || {}
    end

    def iso_config
      @iso_config ||= PimIso::Config.new(project_dir: @project_dir)
    end

    private

    def load_runtime_config
      config = {}

      # Global runtime config
      global_file = File.join(GLOBAL_CONFIG_DIR, 'pim.yml')
      config = DeepMerge.merge(config, load_yaml(global_file))

      # Project runtime config
      project_file = File.join(@project_dir, 'pim.yml')
      config = DeepMerge.merge(config, load_yaml(project_file))

      config
    end

    def load_yaml(path)
      return {} unless File.exist?(path)
      YAML.load_file(path) || {}
    rescue Psych::SyntaxError => e
      warn "Warning: Failed to parse #{path}: #{e.message}"
      {}
    end
  end

  # Profile model with template content resolution
  class Profile
    XDG_CONFIG_HOME = ENV.fetch('XDG_CONFIG_HOME', File.expand_path('~/.config'))
    GLOBAL_CONFIG_DIR = File.join(XDG_CONFIG_HOME, 'pim')

    attr_reader :name, :data

    def initialize(name, data, project_dir: Dir.pwd)
      @name = name
      @data = data
      @project_dir = project_dir
    end

    def to_h
      @data
    end

    def [](key)
      @data[key.to_s]
    end

    def preseed_template(name = nil)
      name ||= @name
      find_template('preseeds.d', "#{name}.cfg.erb") ||
        (name != 'default' && find_template('preseeds.d', 'default.cfg.erb'))
    end

    def install_template(name = nil)
      name ||= @name
      find_template('installs.d', "#{name}.sh") ||
        (name != 'default' && find_template('installs.d', 'default.sh'))
    end

    private

    def find_template(subdir, filename)
      # 1. Project directory
      project_path = File.join(@project_dir, subdir, filename)
      return project_path if File.exist?(project_path)

      # 2. Global config directory
      global_path = File.join(GLOBAL_CONFIG_DIR, subdir, filename)
      return global_path if File.exist?(global_path)

      nil
    end
  end

  # WEBrick server for serving preseed and post-install scripts
  class Server
    def initialize(profile:, port: 8080, verbose: false, preseed_name: nil, install_name: nil)
      @profile = profile
      @port = port
      @verbose = verbose
      @preseed_name = preseed_name
      @install_name = install_name
      @ip = local_ip
    end

    def start
      preseed_path = '/preseed.cfg'
      install_path = '/install.sh'

      # Read install script directly (no ERB)
      install_content = read_file(@profile.install_template(@install_name))

      # Build extended bindings for preseed template
      bindings = @profile.to_h.transform_keys(&:to_sym)
      bindings[:install_url] = "http://#{@ip}:#{@port}#{install_path}" if install_content

      preseed_content = render_template(@profile.preseed_template(@preseed_name), bindings)

      puts "Serving preseed configuration for profile: #{@profile.name}"
      puts
      puts "Preseed URL:      http://#{@ip}:#{@port}#{preseed_path}"
      puts "Install URL:      http://#{@ip}:#{@port}#{install_path}" if install_content
      puts
      puts "Boot parameters:"
      puts "  auto=true priority=critical preseed/url=http://#{@ip}:#{@port}#{preseed_path}"
      puts
      puts "Press Ctrl+C to stop"
      puts

      log_level = @verbose ? WEBrick::Log::DEBUG : WEBrick::Log::WARN
      server = WEBrick::HTTPServer.new(
        Port: @port,
        Logger: WEBrick::Log.new($stdout, log_level),
        AccessLog: @verbose ? [[File.open('/dev/stdout', 'w'), WEBrick::AccessLog::COMMON_LOG_FORMAT]] : []
      )

      server.mount_proc(preseed_path) do |_req, res|
        res['Content-Type'] = 'text/plain'
        res.body = preseed_content
      end

      if install_content
        server.mount_proc(install_path) do |_req, res|
          res['Content-Type'] = 'text/plain'
          res.body = install_content
        end
      end

      trap('INT') { server.shutdown }
      trap('TERM') { server.shutdown }

      server.start
    end

    private

    def render_template(template_path, bindings = nil)
      return nil unless template_path && File.exist?(template_path)

      bindings ||= @profile.to_h.transform_keys(&:to_sym)
      template_content = File.read(template_path)

      # Extract variable references from ERB and provide nil defaults for missing ones
      template_content.scan(/<%=?\s*(\w+)/).flatten.uniq.each do |var|
        bindings[var.to_sym] = nil unless bindings.key?(var.to_sym)
      end

      template = ERB.new(template_content)
      template.result_with_hash(bindings)
    end

    def read_file(path)
      return nil unless path && File.exist?(path)

      File.read(path)
    end

    def local_ip
      Socket.ip_address_list
            .detect { |addr| addr.ipv4? && !addr.ipv4_loopback? }
            &.ip_address || '127.0.0.1'
    end
  end

  # Main CLI interface
  class CLI < Thor
    def self.exit_on_failure? = true
    remove_command :tree

    desc 'serve [PROFILE]', 'Start preseed server for the given profile'
    option :port, type: :numeric, default: 8080, desc: 'Port to serve on'
    option :preseed, type: :string, aliases: '-p', desc: 'Preseed template name (default: profile name)'
    option :install, type: :string, aliases: '-i', desc: 'Post-install script name (default: profile name)'
    option :verbose, type: :boolean, default: false, aliases: '-v', desc: 'Verbose output'
    def serve(profile_name = nil)
      config = Config.new

      # Use runtime defaults if not specified
      profile_name ||= config.serve_defaults['profile'] || 'default'

      profile_data = config.profile(profile_name)

      if profile_data.empty? && profile_name != 'default'
        puts "Error: Profile '#{profile_name}' not found"
        puts "Available profiles: #{config.profile_names.join(', ')}"
        exit 1
      end

      profile = Profile.new(profile_name, profile_data)
      preseed_name = options[:preseed] || profile_name

      unless profile.preseed_template(options[:preseed])
        puts "Error: No preseed template found for '#{preseed_name}'"
        puts "Expected locations:"
        puts "  - ./preseeds.d/#{preseed_name}.cfg.erb"
        puts "  - $XDG_CONFIG_HOME/pim/preseeds.d/#{preseed_name}.cfg.erb"
        exit 1
      end

      server = Server.new(
        profile: profile,
        port: options[:port],
        verbose: options[:verbose],
        preseed_name: options[:preseed],
        install_name: options[:install]
      )

      server.start
    end

    desc 'config', 'Show pim configuration'
    def config
      pim_config = Config.new

      puts "Configuration"
      puts
      puts "ISO:"
      puts "  iso_dir: #{pim_config.iso_config.iso_dir}"
      puts
      puts "Serve:"
      serve_defaults = pim_config.serve_defaults
      if serve_defaults.empty?
        puts "  (no defaults)"
      else
        serve_defaults.each do |key, value|
          puts "  #{key}: #{value}"
        end
      end
    end

    desc 'iso SUBCOMMAND', 'ISO management commands'
    subcommand 'iso', PimIso::CLI

    desc 'profile SUBCOMMAND', 'Profile management commands'
    subcommand 'profile', PimProfile::CLI
  end
end

Pim::CLI.start(ARGV)
